// 인덱스의 특징
// 1. 쿼리를 수행시, 인덱스가 없다면 모든 문서를 일일히 조회하지만
// 인덱스가 있다면 쿼리 작업 검색이 효율적
// 2. 새로운 문서 생성, 수정, 삭제 빈번시 속도 저하가 생김
// 왜냐하면 매번 업데이트를 해야 하기 때문에
// 3. 단순 인덱스(해당 필드만 조회시 사용),
//    복합 인덱스(다수의 필드를 대상으로 조회시 사용)
//4, 복합 인덱스는 순서가 중요
// ex) 제목 :!, 설명 : -1, 이 형식으로 인덱스를 만드기 때문에
// 다른 구조로 사용시 또 자원을 소모해서 사용해야 함
// 5. 인덱스 구조가 예) 복합 : 제목1, 설명-1 인덱스가 있따면
// 단일 인덱스 예) 제목 : 1, 복합 인덱스에 포함이 된다는 사실

//인덱스 종류
// 단일키
// 복합키
// 다중키 : 값이 배열 형태인 곳에 설정 ex) 문서의 속성 중에서 키: 값(배열일 때)
// 텍스트 인덱스 : 범위에 대한 인덱스 사용하는데, 문자열 검색은 범위로
// 검색을 이하고 정확한 문자열 일치여부, 각 단어위주로 검색할 때 사용
// $txet 연산자를 사용시 그래서 텍스트 인덱스가 필요함
// 지리 공간적 인덱스 : pdf 참고, 교재 없음
// 해시 인덱스 : 위의 인덱스 종류는 값으로 (범위로) 인덱스를 지정했다면

db.rating.insertMany([
  { _id: 1, rating: 1, user_id: 2 },
  { _id: 2, rating: 2, user_id: 3 },
  { _id: 3, rating: 3, user_id: 4 },
  { _id: 4, rating: 3, user_id: 1 },
  { _id: 5, rating: 4, user_id: 5 },
  { _id: 6, rating: 4, user_id: 8 },
  { _id: 7, rating: 5, user_id: 9 },
  { _id: 8, rating: 5, user_id: 10 },
  { _id: 9, rating: 5, user_id: 11 },
  { _id: 10, rating: 5, user_id: 12 },
]);

// 교재의 간단한 구조의 인덱스 예제
// 단일키
db.rating.createIndex(
  //시스템에서 rating을 기준으로 인덱스를 만들어 둠
  // 단일 키라서, 해당 rating으로 검색시 효율적인 검색이 가능(빠룸)
  // 1은 오름차순, -1은 내림차순 정렬

  { rating: 1 }
);

db.rating.createIndex(
  //의미, 1차적으로 rating 필드를 기준으로 정렬을 하게 함
  //그 후 두번째 키, user_id를 정렬 하게 됨
  // 임시예제
  // 기준이 되는 키 : rating(중복이 많이 되는 경우, 좀 더 포괄적인 기준을 잡는게 좋음)
  //제약 조건을 정할 때, 큰 범주를 잡고, 작은 범주를 선택
  { rating: 1, user_id: -1 }
);

db.rating.createIndex({ "리뷰.제목": 1 });

db.rating.createIndex({ 제목: "text" });

//해시 인덱스 : 값을 -> 해쉬(특정값으로 변경)
// 값의 일치 여부가 중요한 곳에 사용
// 예) 영화사 이름처럼 값이 꼭 일치 해야한느 부분
// 예 고유값에 설정 함

db.rating.createIndex({ 배급사: hashed });
